# How to implement a new ISA
This document will show you how you can add a new instruction set architecture (ISA) to the architecture simulator. These points are all just suggestions and you can do things differently if you want.

- Create a class that represents the architectural state of your ISA - like the data memory, instruction memory, registers and program counter. Inside of `/architecture_simulator/uarch/`, there are already some classes for this, like `Memory`, `InstructionMemory` and `RegisterFile`. They will probably not perfectly fit your architecture, but you can abstract and modify them (as long as you don't break anything for the other ISAs) to make it work.
- Create a child class of `architecture_simulator/uarch/performance_metrics.PerformanceMetrics` that will contain statistics about your simulation. The base class already provides a few things, like functions for a timer. Add these performance metrics to your architectural state.
- Add the instructions themselves. Under `/architecture_simulator/isa/`, create a folder for your ISA. Create a python file in which you define and implement one class for each instruction. It is a good idea to create different superclasses for different instruction types. All instruction classes should be subclasses of one common class (like `RiscvInstruction`) and this class should be a subclass of `architecture_simulator.isa.instruction.Instruction`. The `Instruction` class doesn't provide you with any functionality on its own, but it allows you to save your instructions in the `architecture_simulator.uarch.instruction_memory.InstructionMemory` class. Add a `behavior()` method to the individual instruction classes which takes an architectural state as parameter and which executes the behavior on the given state. Other things you might want to implement for the instrucion classes are `__repr__` and `__eq__` (for testing) functions or several functions for implementing a pipeline, if you want to make one. One last thing: Create a `instruction_map` dict which maps the mnemonics (str) to the instruction classes. You might need it later.
- Add a parser to the folder you created in `/architecture_simulator/isa/`. We used PyParsing for this - you can look at our code to see how it works. We recommend creating a parser class that provides a `parse()` function which takes the program to be loaded and the entire architectural state, because your assembly programs might not only include instructions, but also a data section and who knows what. You can import and use some of the `ParserExceptions` from `/architecture_simulator/isa/parser_exceptions.py` if you want. After tokenization, you can instantiate instruction objects by getting the class from the `instruction_map` you created earlier. Keep in mind that mypy might complain because you are storing lots of different classes with lots of different constructors in one data structure and it does not immediately know which constructor an object you pulled from the `instruction_map` has. The way we did it (with lots of `**kwargs`) works, but it might not be the best solution. I described the problem further in `/architecture_simulator/isa/toy/toy_instructions.py`, if you care.
- Add a simulation class to `/architecture_simulator/simulation/` which is a subclass of the abstract base class (ABC) `architecture_simulator.simulation.simulation.Simulation`. This is an ABC so that you have to implement some basic interface methods, like `step()` and `load_program()`. The simulation should hold an architectural state and act as a common interface for all ISAs (which should also make it easier to add your ISA to the web interface).
- For (basically) all of the points above, you can add tests to `/architecture_simulator/tests/`.
- You can also add your ISA to the command line interface defined in `/architecture_simulator/cli/`, but at the time of writing, it is WIP, so I have no idea how to do that.
- If you want to add your ISA to the web UI, there are a couple of things you need to do:
    - In the `webgui/index.html`, add a button next to the other ones for switching the ISA (in the settings menu).
    - `webgui/js/scripts.js` contains event listeners and the functions they should trigger. In there do the following:
        - Create an event listener which listens for clicks on the button you just created and which changes the `selected_isa` variable (not sure if this is the best way to do it).
    - Also create any other html elements inside the index.html that you need. Note that we already have a field for the instruction memory, data memory and registers. If you need something else, you've got to make sure that you hide/display the elements when your ISA is selected.
    - `webgui/js/archsim.js` contains a variable `archsim_js` which has all the functions which you want to be able to call from python. In there, do the following:
        - Add functions that you want to call from python to manipulate the HTML elements if you added any additional elements. There are already functions for the existing elements like the memory table.
    - `architecture_simulator/gui/webgui.py` contains all the python functions that you want to be able to call from javascript. In there, do the following:
        - adapt the function `reset_sim()` to create the simulation from your ISA if it is selected.
        - adapt the function `update_tables()` so that it updates all the UI elements to reflect the current state of the simulation and the architectural state.
