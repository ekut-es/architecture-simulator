# How to implement a new ISA
This document will show you how you can add a new instruction set architecture (ISA) to the architecture simulator. These points are all just suggestions and you can do things differently if you want.

- Create a class that represents the architectural state of your ISA - like the data memory, instruction memory, registers and program counter. Inside of `/architecture_simulator/uarch/`, there are already some classes for this, like `Memory`, `InstructionMemory` and `RegisterFile`. They will probably not perfectly fit your architecture, but you can abstract and modify them (as long as you don't break anything for the other ISAs) to make it work. You can also add performance metrics to the architectural state (there is a class `architecture_simulator.uarch.performance_metrics.PerformanceMetrics` which you can use, but it might not suit your ISA).
- Add the instructions themselves. Under `/architecture_simulator/isa/`, create a folder for your ISA. Create a python file in which you define and implement one class for each instruction. It is a good idea to create different superclasses for different instruction types. All instruction classes should be subclasses of one common class (like `RiscvInstruction`) and this class should be a subclass of `architecture_simulator.isa.instruction.Instruction`. The `Instruction` class doesn't provide you with any functionality on its own, but it allows you to save your instructions in the `architecture_simulator.uarch.instruction_memory.InstructionMemory` class. Add a `behavior()` method to the individual instruction classes which takes an architectural state as parameter and which executes the behavior on the given state. Other things you might want to implement for the instrucion classes are `__repr__` and `__eq__` (for testing) functions or several functions for implementing a pipeline, if you want to make one.
- Add a parser to the folder you created in `/architecture_simulator/isa/`. We used PyParsing for this - you can look at our code to see how it works. We recommend creating a parser class that provides a `parse()` function which takes the program to be loaded and the entire architectural state, because your assembly programs might not only include instructions, but also a data section and who knows what. You can import and use some of the `ParserExceptions` from `/architecture_simulator/isa/riscv/riscv_parser.py` if you want.
- Add a simulation class to `/architecture_simulator/simulation/` which is a subclass of the abstract base class (ABC) `architecture_simulator.simulation.simulation.Simulation`. This is an ABC so that you have to implement some basic interface methods, like `step()` and `load_program()`. The simulation should hold an architectural state and act as a common interface for all ISAs (which should also make it easier to add your ISA to the web interface).
- For (basically) all of the points above, you can add tests to `/architecture_simulator/tests/`.
- You can also add your ISA to the command line interface defined in `/architecture_simulator/cli/`, but at the time of writing, it is WIP, so I have no idea of how to do that.
- You can also add your ISA to the web UI, but we have not done that for any ISAs other than RISC-V, so the web UI is tailored for that. We use pyodide to execute python code from the browser. You can find our python code for the interface between the front end and the back end in `/architecture_simulator/gui/webgui.py` and all our front-end related code is inside `/webgui/`.
