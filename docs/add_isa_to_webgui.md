# How to add an ISA to the Web GUI

We use [pyodide](https://pyodide.org/en/stable/) for running our python code in the browser. It allows you to call your python functions from js and then access return values and variables as though they were normal js variables.

For creating the UI, we use the [VueJS](https://vuejs.org/) framework. It allows you to bind your js variables to your HTML, which will save you a lot of awkward dynamic HTML node creation and event listener setups. We use the composition API and SFCs together with a build step.

Before starting to add your ISA to the webgui, you should get familiar with those two projects.

Providing an exact step-by-step guide is kind of hard, but I'll try it anyway. I highly recommend looking at the existing code from other ISAs to find out how to do things and which things you can reuse.

1. Add your isa to the supported ISAs in `/webgui/src/main.js` in the `getDefaultIsa()` function. This will allow users to select your ISA with the `isa` GET parameter.
1. In `/webgui/src/js/global_settings.js`, go to the `setSelectedIsa()` function and add you ISA to it. The global settings object will be used in a number of places - one of its purposes is checking the ISA the user selected.
1. In `/webgui/src/components/SettingsModal.vue`, add your ISA to the `RadioSettingsRow` that is used for selecting an ISA. The name and value should match what you entered in the `global_settings.js`.
1. Create a directory `/webgui/src/components/_yourISA_/` that will contain all your Vue components.
1. In your components folder, create a help page, a settings page and a main component. You can leave them empty for now, but you should create them now because they will have to be incorporated into existing code/components. After doing this, you will (mostly) only have to work inside your main component.
    1. Add your settings page component to `/webgui/src/components/SettingsModal.vue`. Take a look at the settings pages from other ISAs to find out how to style your settings consistently and which components you can reuse.
    1. Add your help page component to `/webgui/src/components/HelpModal.vue`.
    1. Add your main component to `/webgui/src/App.vue`.
1. Before you start working on interacting with your python code, you should know some other things.
The help page you just added will be accessible through the page header, which will always be there.
Your main component will take up the rest of the page. But there won't be a way for the user to go to the settings page, since the settings button is part of the control bar, which is part of the main component. We did it this way because the control bar might be very different for different ISAs. So one of the things you need to do is create a control bar that looks much like the control bars of the existing ISAs and that provides a button for going to the settings page. Go to the other ISA's code to see how to do that.
1. Our existing ISAs all provide a code editor, tables for showing the contents of the memory and registers as well as an output field and a visualization.
Now that is quite a lot of stuff to show - it doesn't fit on most screens. Because of that, we've used [SplitJS](https://split.js.org/) for making the "text content container" and the "visualization container" resizable. There is a class `/webgui/src/js/archsim-split.js` you can use for that.
We've also added buttons for toggling the visibility of individual UI elements. Also, when the user starts the simulation, we hide the input field. You can do this too, but you don't have to.
If you want to use these toggle Buttons, you can use `/webgui/src/components/ToggleButton.vue` for that (it doesn't do that much though). You will also need to destroy/create the split if a container becomes empty. You can take a look at the existing main components for that.
1. We recommend that you use the existing `/webgui/src/components/CodeEditor.vue` as your editor, which uses [CodeMirror 6](https://codemirror.net/). Our component provides a number of features, such as highlighting syntax errors, automatic parsing and up- and downloading files.
For these features to work, you need to pass the editor component your simulation store and also the name of your isa - the latter is used for calling the `useEditorStore()` function from `/webgui/src/js/editor_store.js`, which will create/return one instance of the `EditorStore` class. I'm only telling you that because you might need to call some functions of your editor store in other components (like your control buttons) too. If you want to do so, simply use the `useEditorStore()` function.
1. So how can you interact with your python simulation class? First of all, create a simulation store class in `/webgui/src/js/`. In there, you need to create a class that extends the `BaseSimulationStore` class from `/webgui/src/js/base_simulation_store.js`. This base class already provides a lot of functionality, like functions for parsing, running, stepping, pausing, resetting the simulation, ... You will also find a `syncAll()` method in there. It is used for synchronising the variables of the python simulation class to your java script class. In your own class, you will also need to provide synchronization methods for all of your custom UI elements and then overwrite the `syncAll()` method (but don't forget to still call the super method). This is needed so that you can create a reactive instance of your singleton simulation store and then let Vue automatically update the UI based on the state of your simulation.
You also need to create and export a function that will return a reactive instance of your singleton simulation store and create one if none has been created yet. Then in all the places where you need access to your simulation store, you can call that method.
Since the `BaseSimulationStore` needs a pyodide interface instance, you need to give it one. Pyodide will be loaded in `/webgui/src/main.js`. Create and export a function to set pyodide in your simulation store js file and then call that function from `main.js`.
There are two methods in the base class that are very important but their purpose might not be so obvious: the `toJsSafe()` method will convert a `pyProxy` to js and then destroy the original proxy as well as all intermediary proxies that were created during conversion, to prevent memory leaks. The method `updateLastPythonError()` will grab the last error that occured in python and set is as `this.error`. It will actually use our `get_last_error()` function for that and the return value is not the actual error object, but something different. All of this is needed to prevent memory leaks. Look at the python method from `/architecture_simulator/gui/webgui.py` to find out what it returns. In the methods of your simulation store, you should wrap interactions with try catch blocks and in case of an error, call the `updateLastPythonError()` method. The editor will automatically highlight syntax errors and you can handle other errors yourself. `this.error` will be reset before parsing and when resetting the simulation - you should not need to do that.
1. You'll probably also want to create a settings object singleton that will store settings that are specific to your ISA. You can do that in `/webgui/src/js/`.
1. If you want to provide a visualization, you can use the `/webgui/src/components/SvgVisualization.vue` component. It will use the `svgDirectives` property of your simulation store, so you need to create that variable and synchronise it in your `syncAll()` method if you want to use this component. This property needs to be a list of exported `SvgDirectives`. This class contains the id of the element which shall be used, the type of operation and all needed parameters. Our js code then simply iterates over this list and does what is says. You can find the base class `/architecture_simulator/gui/svg_directives.py`. In the `gui/` folder, you can also find various other classes for the svg directives for TOY - take a look at them to see how to work with them (the ones from RISC-V are a bit weird, I would not recommend doing it like that).

Lastly I want to tell you that all of this is just how we currently do things, but that doesn't mean that this is the best way of doing things. If you think you can improve things (like making code/components more reusable), feel free to do so.
