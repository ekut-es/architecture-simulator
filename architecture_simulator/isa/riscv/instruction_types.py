from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, TYPE_CHECKING
import fixedint

from architecture_simulator.uarch.riscv.control_unit_signals import ControlUnitSignals
from ..instruction import Instruction

if TYPE_CHECKING:
    from architecture_simulator.uarch.riscv.riscv_architectural_state import (
        RiscvArchitecturalState,
    )


@dataclass
class RiscvInstruction(Instruction):
    mnemonic: str
    length: int = 4

    def __init__(self, **kwargs):
        """NOTE: I wrote a super long comment for why we use **kwargs here in architecture_simulator.isa.toy.toy_instructions.ToyInstruction"""
        self.mnemonic = kwargs["mnemonic"]

    def behavior(self, architectural_state: RiscvArchitecturalState):
        """Make the instruction perform all its actions on the given architectural state.

        Args:
            architectural_state (ArchitecturalState): The state to perform the actions on.
        """

    def access_register_file(
        self, architectural_state: RiscvArchitecturalState
    ) -> tuple[
        Optional[int], Optional[int], Optional[int], Optional[int], Optional[int]
    ]:
        """Get the addresses and the data and the immediate the instruction needs from the register file.

        Args:
            architectural_state (ArchitecturalState): architectural state

        Returns:
            tuple[Optional[int], Optional[int], Optional[int], Optional[int], Optional[int]]: Tuple of register_read_addr_1, register_read_addr_2, register_read_data_1, register_read_data_2, imm
        """
        return None, None, None, None, None

    def alu_compute(
        self, alu_in_1: Optional[int], alu_in_2: Optional[int]
    ) -> tuple[Optional[bool], Optional[int]]:
        """Compute the results of the ALU.

        Args:
            alu_in_1 (Optional[int]): ALU input 1
            alu_in_2 (Optional[int]): ALU input 2

        Returns:
            tuple[Optional[bool], Optional[int]]: Tuple of branch taken flag (whether the branch condition is true, if it is a branch instruction) and result of the computation
        """
        return None, None

    def control_unit_signals(self) -> ControlUnitSignals:
        """Return all signals generated by the control unit.

        Returns:
            ControlUnitSignals: object holding all control signals generated by the control unit.
        """

        return ControlUnitSignals()

    def get_write_register(self) -> Optional[int]:
        """Returns the register to which the instruction writes.

        Returns:
            Optional[int]: index of the register to which the instruction writes or none if it doesn't write into the register file.
        """
        return None

    def memory_access(
        self,
        memory_address: Optional[int],
        memory_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ) -> Optional[int]:
        """Performs memory read and write operations and returns the read data if the instruction reads from the memory.

        Args:
            memory_address (Optional[int]): Address where the instruction accesses the memory or None.
            memory_write_data (Optional[int]): Data to be written to the memory or None.
            architectural_state (ArchitecturalState): architectural state.

        Returns:
            Optional[int]: Data read from memory or None if there was no read operation.
        """
        return None

    def write_back(
        self,
        write_register: Optional[int],
        register_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ):
        """Perform register write back operation.

        Args:
            write_register (Optional[int]): register index to write the data to or None.
            register_write_data (Optional[int]): Data to be written to the register. Needs to be casted to fixedint.MutableUInt32
            architectural_state (ArchitecturalState): architectural state
        """


class RTypeInstruction(RiscvInstruction):
    """Create an R-Type instruction

    Args:
        rd (int): register destination
        rs1 (int): source register 1
        rs2 (int): source register 2
    """

    def __init__(self, rd: int, rs1: int, rs2: int, **args):
        super().__init__(**args)
        self.rs1 = rs1
        self.rs2 = rs2
        self.rd = rd

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rd}, x{self.rs1}, x{self.rs2}"

    def access_register_file(
        self, architectural_state: RiscvArchitecturalState
    ) -> tuple[
        Optional[int], Optional[int], Optional[int], Optional[int], Optional[int]
    ]:
        return (
            self.rs1,
            self.rs2,
            int(architectural_state.register_file.registers[self.rs1]),
            int(architectural_state.register_file.registers[self.rs2]),
            None,
        )

    def control_unit_signals(self) -> ControlUnitSignals:
        # jump, alu_op
        return ControlUnitSignals(
            alu_src_1=True,
            alu_src_2=False,
            wb_src=2,
            reg_write=True,
            mem_read=False,
            mem_write=False,
            branch=False,
            jump=False,
            alu_op=2,
            alu_to_pc=False,
        )

    def get_write_register(self) -> Optional[int]:
        return self.rd

    def memory_access(
        self,
        memory_address: Optional[int],
        memory_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ) -> Optional[int]:
        return None

    def write_back(
        self,
        write_register: Optional[int],
        register_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ):
        assert write_register is not None
        assert register_write_data is not None
        architectural_state.register_file.registers[
            write_register
        ] = fixedint.MutableUInt32(register_write_data)


class ITypeInstruction(RiscvInstruction):
    def __init__(self, rd: int, rs1: int, imm: int, **args):
        """Create an I-Type instruction

        Args:
            imm (int): offset to be further progressed by the instruction
            rs1 (int): source register 1
            rd (int): destination register
        """
        super().__init__(**args)
        self.rs1 = rs1
        self.rd = rd
        self.imm = (imm & (2**11) - 1) - (imm & 2**11)  # 12-bit sext

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rd}, x{self.rs1}, {self.imm}"

    def access_register_file(
        self, architectural_state: RiscvArchitecturalState
    ) -> tuple[
        Optional[int], Optional[int], Optional[int], Optional[int], Optional[int]
    ]:
        return (
            self.rs1,
            None,
            int(architectural_state.register_file.registers[self.rs1]),
            None,
            self.imm,
        )

    def control_unit_signals(self) -> ControlUnitSignals:
        return ControlUnitSignals(
            alu_src_1=True,
            alu_src_2=True,
            wb_src=2,
            reg_write=True,
            mem_read=False,
            mem_write=False,
            branch=False,
            jump=False,
            alu_op=2,
            alu_to_pc=False,
        )

    def get_write_register(self) -> Optional[int]:
        return self.rd

    def memory_access(
        self,
        memory_address: Optional[int],
        memory_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ) -> Optional[int]:
        return None

    def write_back(
        self,
        write_register: Optional[int],
        register_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ):
        assert write_register is not None
        assert register_write_data is not None
        architectural_state.register_file.registers[
            write_register
        ] = fixedint.MutableUInt32(register_write_data)


class MemoryITypeInstruction(ITypeInstruction):
    """A special class for memory type instructions because they should have a different __repr__."""

    def __init__(self, rd: int, rs1: int, imm: int, **args):
        """Create an I-Type instruction that requires memory access

        Args:
            imm (int): offset to be further progressed by the instruction
            rs1 (int): source register 1
            rd (int): destination register
        """
        super().__init__(rd, rs1, imm, **args)

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rd}, {self.imm}(x{self.rs1})"

    def control_unit_signals(self) -> ControlUnitSignals:
        return ControlUnitSignals(
            alu_src_1=True,
            alu_src_2=True,
            wb_src=1,
            reg_write=True,
            mem_read=True,
            mem_write=False,
            branch=False,
            jump=False,
            alu_op=0,
            alu_to_pc=False,
        )


class ShiftITypeInstruction(ITypeInstruction):
    """A special class for shift type instructions because they require a different length immediate than normal I-Types."""

    def __init__(self, rd: int, rs1: int, imm: int, **args):
        """Create an I-Type instruction that requires shamt

        Args:
            imm (int): shift amount
            rs1 (int): source register 1
            rd (int): destination register
        """
        super().__init__(rd, rs1, imm, **args)
        self.imm = imm & (2**5) - 1  # [0:5]

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rd}, x{self.rs1}, {self.imm}"


class STypeInstruction(RiscvInstruction):
    def __init__(self, rs1: int, rs2: int, imm: int, **args):
        """Create an S-Type instruction

        Args:
            rs1 (int): source register 1
            rs2 (int): source register 2
            imm (int): offset to be added to the rs1
        """
        super().__init__(**args)
        self.rs1 = rs1
        self.rs2 = rs2
        self.imm = (imm & 2047) - (imm & 2048)  # 12-bit sext

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rs2}, {self.imm}(x{self.rs1})"

    def alu_compute(
        self, alu_in_1: Optional[int], alu_in_2: Optional[int]
    ) -> tuple[Optional[bool], Optional[int]]:
        if alu_in_1 is not None and alu_in_2 is not None:
            res = alu_in_1 + alu_in_2
            return (None, res)
        else:
            return (None, None)

    def control_unit_signals(self) -> ControlUnitSignals:
        # jump, alu_op
        return ControlUnitSignals(
            alu_src_1=True,
            alu_src_2=True,
            wb_src=None,
            reg_write=False,
            mem_read=False,
            mem_write=True,
            branch=False,
            jump=False,
            alu_op=0,
            alu_to_pc=False,
        )


class BTypeInstruction(RiscvInstruction):
    def __init__(self, rs1: int, rs2: int, imm: int, **args):
        """Create a B-Type instruction
        Note: These B-Type-Instructions will actually set the pc to imm-length, because the simulator will always add the instruction length in bytes to the pc.

        Args:
            rs1 (int): source register 1
            rs2 (int): source register 2
            imm (int): offset to be added to the pc. Needs to be a 13 bit signed integer. Interpreted as number of bytes.
        """
        super().__init__(**args)
        self.rs1 = rs1
        self.rs2 = rs2
        self.imm = (imm & 4095) - (imm & 4096)  # 13-bit sext

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rs1}, x{self.rs2}, {self.imm}"

    def access_register_file(
        self, architectural_state: RiscvArchitecturalState
    ) -> tuple[
        Optional[int], Optional[int], Optional[int], Optional[int], Optional[int]
    ]:
        return (
            self.rs1,
            self.rs2,
            int(architectural_state.register_file.registers[self.rs1]),
            int(architectural_state.register_file.registers[self.rs2]),
            self.imm,
        )

    def control_unit_signals(self) -> ControlUnitSignals:
        return ControlUnitSignals(
            alu_src_1=True,
            alu_src_2=False,
            wb_src=None,
            reg_write=False,
            mem_read=False,
            mem_write=False,
            branch=True,
            jump=False,
            alu_op=1,
            alu_to_pc=False,
        )


class UTypeInstruction(RiscvInstruction):
    def __init__(self, rd: int, imm: int, **args):
        super().__init__(**args)
        self.rd = rd
        self.imm = (imm & (2**19) - 1) - (imm & 2**19)  # 20-bit sext

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rd}, {self.imm}"

    def get_write_register(self) -> int | None:
        return self.rd

    def write_back(
        self,
        write_register: Optional[int],
        register_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ):
        assert write_register is not None
        assert register_write_data is not None
        architectural_state.register_file.registers[
            write_register
        ] = fixedint.MutableUInt32(register_write_data)

    def access_register_file(
        self, architectural_state: RiscvArchitecturalState
    ) -> tuple[int | None, int | None, int | None, int | None, int | None]:
        return None, None, None, None, self.imm << 12


class JTypeInstruction(RiscvInstruction):
    def __init__(self, rd: int, imm: int, **args):
        super().__init__(**args)
        self.rd = rd
        self.imm = (imm & (2**20) - 1) - (imm & 2**20)  # 21-bit sext

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rd}, {self.imm}"

    def control_unit_signals(self) -> ControlUnitSignals:
        return ControlUnitSignals(
            alu_src_1=None,
            alu_src_2=None,
            wb_src=0,
            reg_write=True,
            mem_read=False,
            mem_write=False,
            branch=False,
            jump=True,
            alu_op=None,
            alu_to_pc=False,
        )

    def get_write_register(self) -> int | None:
        return self.rd

    def write_back(
        self,
        write_register: Optional[int],
        register_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ):
        assert write_register is not None
        assert register_write_data is not None
        architectural_state.register_file.registers[
            write_register
        ] = fixedint.MutableUInt32(register_write_data)

    def access_register_file(
        self, architectural_state: RiscvArchitecturalState
    ) -> tuple[int | None, int | None, int | None, int | None, int | None]:
        return None, None, None, None, self.imm


class FenceTypeInstruction(RiscvInstruction):
    def __init__(self, **args):
        super().__init__(**args)

    # TODO: Change me, if Fence gets implemented
    # def __repr__(self) -> str:
    #    return f"{self.mnemonic}"


class CSRTypeInstruction(RiscvInstruction):
    def __init__(self, rd: int, csr: int, rs1: int, **args):
        """Create a CSR-Type instruction

        Args:
            rd (int): register destination
            csr (int): the control/status register's index
            rs1 (int): source register 1
        """
        super().__init__(**args)
        self.rd = rd
        self.csr = csr
        self.rs1 = rs1

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rd}, {hex(self.csr)}, x{self.rs1}"


class CSRITypeInstruction(RiscvInstruction):
    def __init__(self, rd: int, csr: int, uimm: int, **args):
        """Create a CSRI-Type instruction

        Args:
            rd (int): register destination
            csr (int): the control/status register's index
            uimm (int): immediate
        """
        super().__init__(**args)
        self.rd = rd
        self.csr = csr
        self.uimm = uimm & (2**5) - 1  # [0:5]

    def __repr__(self) -> str:
        return f"{self.mnemonic} x{self.rd}, {hex(self.csr)}, {self.uimm}"


class EmptyInstruction(RiscvInstruction):
    """A special class for "empty" instructions. These are used only in the pipeline because the stages cannot just contain nothing.
    This should maybe get replaced by a real instruction which just does nothing (like add x0, x0, x0).
    But you would have to figure out when to stop the pipeline then.
    """

    def __init__(self, **kwargs):
        super().__init__(mnemonic="Empty")

    def access_register_file(
        self, architectural_state: RiscvArchitecturalState
    ) -> tuple[
        Optional[int], Optional[int], Optional[int], Optional[int], Optional[int]
    ]:
        return (None, None, None, None, None)

    def alu_compute(
        self, alu_in_1: Optional[int], alu_in_2: Optional[int]
    ) -> tuple[Optional[bool], Optional[int]]:
        return (None, None)

    def control_unit_signals(self) -> ControlUnitSignals:
        return ControlUnitSignals()

    def get_write_register(self) -> Optional[int]:
        return None

    def memory_access(
        self,
        memory_address: Optional[int],
        memory_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ) -> Optional[int]:
        return None

    def write_back(
        self,
        write_register: Optional[int],
        register_write_data: Optional[int],
        architectural_state: RiscvArchitecturalState,
    ):
        pass
